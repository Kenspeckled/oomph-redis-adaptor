// Generated by CoffeeScript 1.9.3
(function() {
  var Promise, _, _utilities, generateId, generateUniqueId, indexSearchableString, indexSortedSet, numberOfExtraCharactersOnId, oomph, performValidations, sendAttributesForSaving, writeAttributes,
    slice = [].slice;

  Promise = require('promise');

  oomph = require('oomph');

  _ = require('lodash');

  _utilities = require('./utilities');

  numberOfExtraCharactersOnId = 2;

  generateId = function() {
    var d, s;
    d = new Date();
    s = (+d).toString(36);
    return s + _utilities.randomString(numberOfExtraCharactersOnId);
  };

  generateUniqueId = function() {
    var condition, newIdPromise, self, uniqueId;
    self = this;
    uniqueId = false;
    condition = function() {
      return uniqueId === false;
    };
    return newIdPromise = _utilities.promiseWhile(condition, function() {
      return new Promise(function(resolve) {
        var id;
        id = generateId();
        return self.redis.lrange(self.className + '#uniqueIds', 0, -1, function(error, idsArray) {
          if (_.includes(idsArray, id)) {
            id = generateId();
            return resolve();
          } else {
            return self.redis.rpush(self.className + '#uniqueIds', id, function(error, response) {
              uniqueId = true;
              return resolve(id);
            });
          }
        });
      });
    });
  };

  indexSortedSet = function(setKey, attr) {
    var addToTmpSetPromise, listKey, setTmpKey, sortPromise;
    listKey = setKey + 'TempList' + _utilities.randomString(3);
    setTmpKey = setKey + 'TempList' + _utilities.randomString(3);
    sortPromise = new Promise((function(_this) {
      return function(resolve, reject) {
        return _this.redis.sort(setKey, 'by', _this.className + ':*->' + attr, 'alpha', 'store', listKey, function(error, newLength) {
          return resolve(newLength);
        });
      };
    })(this));
    addToTmpSetPromise = sortPromise.then((function(_this) {
      return function(listLength) {
        var multi;
        multi = _this.redis.multi();
        return new Promise(function(resolve, reject) {
          _.times(listLength, function() {
            return multi.lpop(listKey);
          });
          return multi.exec(function(error, ids) {
            var addToSet;
            addToSet = _.map(ids, function(id, i) {
              return new Promise(function(r) {
                return _this.redis.zadd(setTmpKey, listLength - i, id, function(res) {
                  return r();
                });
              });
            });
            return resolve(Promise.all(addToSet));
          });
        });
      };
    })(this));
    return addToTmpSetPromise.then((function(_this) {
      return function() {
        return new Promise(function(resolve) {
          return _this.redis.rename(setTmpKey, setKey, function(res) {
            return resolve();
          });
        });
      };
    })(this));
  };

  indexSearchableString = function(attr, words, id) {
    var char, indexPromiseFn, indexPromises, j, k, len, len1, ref, word, wordSegment, wordSegmentKey;
    indexPromises = [];
    ref = words.split(/\s/);
    for (j = 0, len = ref.length; j < len; j++) {
      word = ref[j];
      word = word.toLowerCase();
      wordSegment = '';
      for (k = 0, len1 = word.length; k < len1; k++) {
        char = word[k];
        wordSegment += char;
        wordSegmentKey = this.className + '#' + attr + '/' + wordSegment;
        indexPromiseFn = (function(_this) {
          return function(wordSegmentKey, id) {
            return new Promise(function(resolve) {
              return _this.redis.zadd(wordSegmentKey, 1, id, function(res) {
                return resolve();
              });
            });
          };
        })(this);
        indexPromises.push(indexPromiseFn(wordSegmentKey, id));
      }
    }
    return Promise.all(indexPromises);
  };

  writeAttributes = function(props) {
    var idPromise, indexPromise, newObjectFlag, self, writePromise;
    self = this;
    newObjectFlag = false;
    idPromise = new Promise(function(resolve) {
      if (!props.id) {
        newObjectFlag = true;
        return generateUniqueId.apply(self).then(function(id) {
          return resolve(id);
        });
      } else {
        return resolve(props.id);
      }
    });
    writePromise = idPromise.then(function(id) {
      var attr, findExistingAttr, identifier, obj, ref, storableProps, writeCallbackPromises;
      props.id = id;
      storableProps = _.clone(props, true);
      writeCallbackPromises = [];
      ref = self.classAttributes;
      for (attr in ref) {
        obj = ref[attr];
        switch (obj.dataType) {
          case 'integer':
            if (storableProps[attr]) {
              storableProps[attr + '[i]'] = props[attr];
              props[attr] = +props[attr];
              delete storableProps[attr];
            }
            break;
          case 'boolean':
            if (storableProps[attr] !== void 0) {
              storableProps[attr + '[b]'] = props[attr];
              props[attr] = !!props[attr];
              delete storableProps[attr];
            }
            break;
          case 'reference':
            if (obj.many) {
              delete storableProps[attr];
              if (newObjectFlag) {
                storableProps[attr] = true;
              }
            }
            break;
          case 'string':
            if (obj.identifier) {
              identifier = _utilities.urlString(props[attr]);
              storableProps[attr] = identifier;
              props[attr] = identifier;
            }
            if (obj.url && obj.urlBaseAttribute && props[obj.urlBaseAttribute]) {
              findExistingAttr = function(attr, identifier) {
                var condition, counter, isUnique;
                isUnique = false;
                condition = function() {
                  return !isUnique;
                };
                counter = 0;
                return _utilities.promiseWhile(condition, function() {
                  return new Promise(function(resolve) {
                    var modifiedIdentifier;
                    modifiedIdentifier = identifier;
                    if (counter > 0) {
                      modifiedIdentifier += '-' + counter;
                    }
                    counter += 1;
                    return self.redis.get(self.className + "#" + attr + ':' + modifiedIdentifier, function(err, res) {
                      storableProps[attr] = modifiedIdentifier;
                      props[attr] = modifiedIdentifier;
                      if (!res) {
                        isUnique = true;
                      }
                      return resolve();
                    });
                  });
                });
              };
              if (newObjectFlag || storableProps[attr]) {
                identifier = storableProps[attr] ? _utilities.urlString(storableProps[attr]) : _utilities.urlString(props[obj.urlBaseAttribute]);
                writeCallbackPromises.push(findExistingAttr(attr, identifier));
              }
            }
        }
      }
      return Promise.all(writeCallbackPromises).then(function() {
        return new Promise(function(resolve) {
          return self.redis.hmset(self.className + ":" + props.id, storableProps, function(err, res) {
            return resolve(storableProps);
          });
        });
      });
    });
    indexPromise = writePromise.then(function(storedProps) {
      var attr, indexPromiseFn, indexingPromises, multi, multipleValues, namespace, obj, ref, sortedSetName, value;
      indexingPromises = [];
      multi = self.redis.multi();
      indexPromiseFn = function(sortedSetName, attributeName, propsId) {
        var largestSortedSetSize;
        largestSortedSetSize = 9007199254740992;
        return new Promise(function(resolve) {
          return self.redis.zadd(sortedSetName, largestSortedSetSize, propsId, function(error, res) {
            return indexSortedSet.apply(self, [sortedSetName, attributeName]).then(function() {
              return resolve();
            });
          });
        });
      };
      sortedSetName = self.className + ">id";
      indexingPromises.push(indexPromiseFn(sortedSetName, "id", props.id));
      ref = self.classAttributes;
      for (attr in ref) {
        obj = ref[attr];
        if (props[attr] === void 0) {
          continue;
        }
        value = props[attr];
        switch (obj.dataType) {
          case 'integer':
            sortedSetName = self.className + ">" + attr;
            multi.zadd(sortedSetName, parseInt(value), props.id);
            break;
          case 'string':
            if (obj.sortable) {
              sortedSetName = self.className + ">" + attr;
              indexingPromises.push(indexPromiseFn(sortedSetName, attr, props.id));
            }
            if (obj.identifiable || obj.url) {
              multi.set(self.className + "#" + attr + ":" + value, props.id);
            }
            if (obj.searchable) {
              value = _utilities.sanitisedString(value);
              indexingPromises.push(indexSearchableString.apply(self, [attr, value, props.id]));
            }
            break;
          case 'text':
            if (obj.searchable) {
              value = _utilities.sanitisedString(value);
              indexingPromises.push(indexSearchableString.apply(self, [attr, value, props.id]));
            }
            break;
          case 'boolean':
            if (_.includes([true, 'true', false, 'false'], value)) {
              multi.zadd(self.className + "#" + attr + ":" + value, 1, props.id);
            }
            break;
          case 'reference':
            namespace = obj.reverseReferenceAttribute || attr;
            if (obj.many) {
              multipleValues = value;
              multi.sadd.apply(multi, [self.className + ":" + props.id + "#" + attr + ':' + obj.referenceModelName + 'Refs'].concat(slice.call(multipleValues)));
              multipleValues.forEach(function(vid) {
                return multi.sadd(obj.referenceModelName + ":" + vid + "#" + namespace + ':' + self.className + 'Refs', props.id);
              });
            } else {
              multi.sadd(obj.referenceModelName + ":" + value + "#" + namespace + ':' + self.className + 'Refs', props.id);
            }
            break;
          default:
            if (obj.dataType !== null) {
              Promise.reject(new Error("Unrecognised dataType " + obj.dataType));
            }
        }
      }
      return new Promise(function(resolve) {
        return multi.exec(function() {
          return Promise.all(indexingPromises).then(function() {
            return resolve(storedProps);
          });
        });
      });
    });
    return indexPromise;
  };

  performValidations = function(validateFields, dataFields) {
    var returnedValidations, self;
    self = this;
    if (_.isEmpty(dataFields)) {
      return Promise.reject(new Error("No valid fields given"));
    }
    returnedValidations = _.map(validateFields, function(attrName) {
      var attrObj, attrValue;
      attrObj = self.classAttributes[attrName];
      if (attrObj && attrObj.validates) {
        attrValue = dataFields[attrName];
        return oomph.validate.apply(self, [attrObj.validates, attrName, attrValue]);
      }
    });
    return Promise.all(returnedValidations).then(function(validationArray) {
      var errors;
      errors = _(validationArray).flattenDeep().compact().value();
      if (!_.isEmpty(errors)) {
        return Promise.reject(errors);
      }
    });
  };

  sendAttributesForSaving = function(dataFields, skipValidation) {
    var attrs, isNewObject, props, sanitisedDataFields, self, validationPromise;
    self = this;
    if (skipValidation) {
      validationPromise = new Promise(function(resolve) {
        return resolve(true);
      });
      props = dataFields;
    } else {
      isNewObject = !dataFields.id;
      if (isNewObject) {
        attrs = ['id'].concat(_.keys(self.classAttributes));
      } else {
        attrs = _.keys(dataFields);
      }
      sanitisedDataFields = _(dataFields).omit(_.isNull).omit(_.isUndefined).pick(attrs).value();
      props = sanitisedDataFields;
      validationPromise = performValidations.apply(self, [attrs, props]);
    }
    return validationPromise.then(function() {
      return writeAttributes.apply(self, [props]);
    });
  };

  module.exports = sendAttributesForSaving;

}).call(this);
