// Generated by CoffeeScript 1.9.3
(function() {
  var Promise, _, _utilities, addToWriteQueue, generateId, generateUniqueId, indexSearchableString, indexSortedSet, numberOfExtraCharactersOnId, oomph, performValidations, processWriteQueue, sendAttributesForSaving, writeAttributes,
    slice = [].slice;

  Promise = require('promise');

  oomph = require('oomph');

  _ = require('lodash');

  _utilities = require('./utilities');

  numberOfExtraCharactersOnId = 2;

  generateId = function() {
    var d, s;
    d = new Date();
    s = (+d).toString(36);
    return s + _utilities.randomString(numberOfExtraCharactersOnId);
  };

  generateUniqueId = function() {
    var condition, newIdPromise, self, uniqueId;
    self = this;
    uniqueId = false;
    condition = function() {
      return uniqueId === false;
    };
    return newIdPromise = _utilities.promiseWhile(condition, function() {
      return new Promise(function(resolve) {
        var id;
        id = generateId();
        return self.redis.lrange(self.className + '#uniqueQueuedIds', 0, -1, function(error, idsArray) {
          if (_.includes(idsArray, id)) {
            id = generateId();
            return resolve();
          } else {
            return self.redis.rpush(self.className + '#uniqueQueuedIds', id, function(error, response) {
              uniqueId = true;
              return resolve(id);
            });
          }
        });
      });
    });
  };

  indexSortedSet = function(setKey, attr) {
    var addToTmpSetPromise, listKey, setTmpKey, sortPromise;
    listKey = setKey + 'TempList';
    setTmpKey = setKey + 'TempList';
    sortPromise = new Promise((function(_this) {
      return function(resolve, reject) {
        return _this.redis.sort(setKey, 'by', _this.className + ':*->' + attr, 'alpha', 'store', listKey, function(error, newLength) {
          return resolve(newLength);
        });
      };
    })(this));
    addToTmpSetPromise = sortPromise.then((function(_this) {
      return function(listLength) {
        var multi;
        multi = _this.redis.multi();
        return new Promise(function(resolve, reject) {
          _.times(listLength, function() {
            return multi.lpop(listKey);
          });
          return multi.exec(function(error, ids) {
            var addToSet;
            addToSet = _.map(ids, function(id, i) {
              return new Promise(function(r) {
                return _this.redis.zadd(setTmpKey, listLength - i, id, function(res) {
                  return r();
                });
              });
            });
            return resolve(Promise.all(addToSet));
          });
        });
      };
    })(this));
    return addToTmpSetPromise.then((function(_this) {
      return function() {
        return new Promise(function(resolve) {
          return _this.redis.rename(setTmpKey, setKey, function(res) {
            return resolve();
          });
        });
      };
    })(this));
  };

  indexSearchableString = function(attr, words, id) {
    var char, indexPromiseFn, indexPromises, j, k, len, len1, ref, word, wordSegment, wordSegmentKey;
    indexPromises = [];
    ref = words.split(/\s/);
    for (j = 0, len = ref.length; j < len; j++) {
      word = ref[j];
      word = word.toLowerCase();
      wordSegment = '';
      for (k = 0, len1 = word.length; k < len1; k++) {
        char = word[k];
        wordSegment += char;
        wordSegmentKey = this.className + '#' + attr + '/' + wordSegment;
        indexPromiseFn = (function(_this) {
          return function(wordSegmentKey, id) {
            return new Promise(function(resolve) {
              return _this.redis.zadd(wordSegmentKey, 1, id, function(res) {
                return resolve();
              });
            });
          };
        })(this);
        indexPromises.push(indexPromiseFn(wordSegmentKey, id));
      }
    }
    return Promise.all(indexPromises);
  };

  writeAttributes = function(props) {
    var idPromise, indexPromise, newObjectFlag, self, writePromise;
    self = this;
    newObjectFlag = false;
    idPromise = new Promise(function(resolve) {
      if (!props.id) {
        newObjectFlag = true;
        return generateUniqueId.apply(self).then(function(id) {
          return resolve(id);
        });
      } else {
        return resolve(props.id);
      }
    });
    writePromise = idPromise.then(function(id) {
      var storableProps;
      props.id = id;
      storableProps = _.clone(props);
      return new Promise(function(resolve) {
        var attr, obj, ref;
        ref = self.classAttributes;
        for (attr in ref) {
          obj = ref[attr];
          switch (obj.dataType) {
            case 'integer':
              if (storableProps[attr]) {
                storableProps[attr + '[i]'] = storableProps[attr];
                delete storableProps[attr];
              }
              break;
            case 'boolean':
              if (storableProps[attr]) {
                storableProps[attr + '[b]'] = storableProps[attr];
                delete storableProps[attr];
              }
              break;
            case 'reference':
              if (obj.many) {
                delete storableProps[attr];
                if (newObjectFlag) {
                  storableProps[attr] = true;
                }
              }
              break;
            case 'string':
              if (obj.url && obj.urlBaseAttribute) {
                if (!storableProps[attr]) {
                  storableProps[attr] = _utilities.urlString(props[obj.urlBaseAttribute]);
                }
              }
          }
        }
        return self.redis.hmset(self.className + ":" + props.id, storableProps, function(err, res) {
          return resolve(storableProps);
        });
      });
    });
    indexPromise = writePromise.then(function(props) {
      var attr, indexPromiseFn, indexingPromises, multi, multipleValues, namespace, obj, ref, sortedSetName, value;
      indexingPromises = [];
      multi = self.redis.multi();
      indexPromiseFn = function(sortedSetName, attributeName) {
        var largestSortedSetSize;
        largestSortedSetSize = 9007199254740992;
        return new Promise(function(resolve) {
          return self.redis.zadd(sortedSetName, largestSortedSetSize, props.id, function(error, res) {
            return indexSortedSet.apply(self, [sortedSetName, attributeName]).then(function() {
              return resolve();
            });
          });
        });
      };
      sortedSetName = self.className + ">id";
      indexingPromises.push(indexPromiseFn(sortedSetName, "id"));
      ref = self.classAttributes;
      for (attr in ref) {
        obj = ref[attr];
        if (props[attr] === void 0) {
          continue;
        }
        value = props[attr];
        switch (obj.dataType) {
          case 'integer':
            sortedSetName = self.className + ">" + attr;
            multi.zadd(sortedSetName, parseInt(value), props.id);
            break;
          case 'string':
            if (obj.sortable) {
              sortedSetName = self.className + ">" + attr;
              indexingPromises.push(indexPromiseFn(sortedSetName, attr));
            }
            if (obj.identifiable || obj.url) {
              multi.set(self.className + "#" + attr + ":" + value, props.id);
            }
            if (obj.searchable) {
              indexingPromises.push(indexSearchableString.apply(self, [attr, value, props.id]));
            }
            break;
          case 'text':
            if (obj.searchable) {
              indexingPromises.push(indexSearchableString.apply(self, [attr, value, props.id]));
            }
            break;
          case 'boolean':
            if (_.includes([true, 'true', false, 'false'], value)) {
              multi.zadd(self.className + "#" + attr + ":" + value, 1, props.id);
            }
            break;
          case 'reference':
            namespace = obj.reverseReferenceAttribute || attr;
            if (obj.many) {
              multipleValues = _.compact(value.split(","));
              multi.sadd.apply(multi, [self.className + ":" + props.id + "#" + attr + ':' + obj.referenceModelName + 'Refs'].concat(slice.call(multipleValues)));
              multipleValues.forEach(function(vid) {
                return multi.sadd(obj.referenceModelName + ":" + vid + "#" + namespace + ':' + self.className + 'Refs', props.id);
              });
            } else {
              multi.sadd(obj.referenceModelName + ":" + value + "#" + namespace + ':' + self.className + 'Refs', props.id);
            }
            break;
          default:
            if (obj['dataType'] !== null) {
              reject(new Error("Unrecognised dataType " + obj.dataType));
            }
        }
      }
      return new Promise(function(resolve) {
        return multi.exec(function() {
          return resolve(Promise.all(indexingPromises));
        });
      });
    });
    return indexPromise.then(function() {
      return props;
    });
  };

  processWriteQueue = function() {
    var condition, hasQueue, processPromise, self, writeReturnObject;
    console.log("processing write queue");
    self = this;
    hasQueue = true;
    condition = function() {
      return hasQueue;
    };
    writeReturnObject = {};
    processPromise = _utilities.promiseWhile(condition, function() {
      console.log("loop");
      return new Promise(function(resolve, reject) {
        return self.redis.rpop(self.className + "#TmpQueue", function(error, tmpId) {
          if (tmpId) {
            return self.redis.hgetall(self.className + "#TmpQueueObj:" + tmpId, function(err, props) {
              self.redis.del(self.className + "#TmpQueueObj:" + tmpId);
              if (props) {
                return writeAttributes.apply(self, [props]).then(function(writtenObject) {
                  writeReturnObject[tmpId] = writtenObject;
                  return resolve();
                });
              } else {
                return reject(new Error("No properties in Queued Object " + self.className + "#TmpQueueObj:" + tmpId));
              }
            });
          } else {
            self.redis.del(self.className + '#uniqueQueuedIds');
            hasQueue = false;
            return resolve(writeReturnObject);
          }
        });
      });
    });
    return processPromise.then(function() {
      _.each(writeReturnObject, function(obj, tmpId) {
        console.log("process", obj, tmpId);
        return oomph.publishSubscribe.broadcast.apply(self, ['attributes_written_' + tmpId, obj]);
      });
      return writeObjectArray;
    });
  };

  addToWriteQueue = function(props) {
    var p, self, tmpId;
    self = this;
    tmpId = "TmpId" + generateId() + _utilities.randomString(12);
    p = new Promise(function(resolve) {
      return self.redis.hmset(self.className + "#TmpQueueObj:" + tmpId, props, (function(_this) {
        return function(err, res) {
          return self.redis.lpush(self.className + "#TmpQueue", tmpId, function(error, newListLength) {
            return resolve(tmpId);
          });
        };
      })(this));
    });
    return p.then(function(tmpId) {
      processWriteQueue.apply(self);
      return new Promise(function(resolve) {
        var resolveFn;
        resolveFn = function(obj) {
          oomph.publishSubscribe.removeAllListenersOn.apply(self, ["attributes_written_" + tmpId]);
          return resolve(obj);
        };
        return oomph.publishSubscribe.listen.apply(self, ['attributes_written_' + tmpId, resolveFn]);
      });
    });
  };

  performValidations = function(dataFields) {
    var returnedValidations;
    if (_.isEmpty(dataFields)) {
      throw new Error("No valid fields given");
    }
    returnedValidations = _.map(this.classAttributes, (function(_this) {
      return function(attrObj, attrName) {
        var attrValue;
        if (attrObj.validates) {
          attrValue = dataFields[attrName];
          return oomph.validate.apply(_this, [attrObj.validates, attrName, attrValue]);
        }
      };
    })(this));
    return Promise.all(returnedValidations).then(function(validationArray) {
      var errors;
      errors = _(validationArray).flattenDeep().compact().value();
      if (!_.isEmpty(errors)) {
        throw errors;
      }
    });
  };

  sendAttributesForSaving = function(dataFields, skipValidation) {
    var attrs, props, sanitisedDataFields, validationPromise;
    if (skipValidation) {
      validationPromise = new Promise(function(resolve) {
        return resolve(true);
      });
      props = dataFields;
    } else {
      attrs = _.keys(this.classAttributes);
      attrs.push("id");
      sanitisedDataFields = _(dataFields).omit(_.isNull).omit(_.isUndefined).pick(attrs).value();
      props = sanitisedDataFields;
      validationPromise = performValidations.apply(this, [props]);
    }
    if (_.isEmpty(props)) {
      throw new Error("Properties are empty");
    }
    return validationPromise.then((function(_this) {
      return function() {
        return addToWriteQueue.apply(_this, [props]);
      };
    })(this), function(validationErrors) {
      throw validationErrors;
    });
  };

  module.exports = sendAttributesForSaving;

}).call(this);
